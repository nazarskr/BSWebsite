/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { VerticalAlignment, HorizontalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
var /**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
AutoPositionStrategy = /** @class */ (function (_super) {
    tslib_1.__extends(AutoPositionStrategy, _super);
    function AutoPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    AutoPositionStrategy.prototype.fitInViewport = /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    function (element, connectedFit) {
        /** @type {?} */
        var transformString = [];
        if (!connectedFit.fitHorizontal) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                /** @type {?} */
                var horizontalPush = this.horizontalPush(connectedFit);
                transformString.push("translateX(" + horizontalPush + "px)");
            }
        }
        if (!connectedFit.fitVertical) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                /** @type {?} */
                var verticalPush = this.verticalPush(connectedFit);
                transformString.push("translateY(" + verticalPush + "px)");
            }
        }
        element.style.transform = transformString.join(' ').trim();
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipHorizontal = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        /** @type {?} */
        var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return connectedFit.viewPortRect.left < leftBorder && rightBorder < connectedFit.viewPortRect.right;
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipVertical = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        /** @type {?} */
        var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return connectedFit.viewPortRect.top < topBorder && bottomBorder < connectedFit.viewPortRect.bottom;
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipHorizontal = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipVertical = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    };
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.horizontalPush = /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var leftExtend = connectedFit.left;
        /** @type {?} */
        var rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    };
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.verticalPush = /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var topExtend = connectedFit.top;
        /** @type {?} */
        var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    };
    return AutoPositionStrategy;
}(BaseFitPositionStrategy));
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
export { AutoPositionStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9hdXRvLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUFFLHVCQUF1QixFQUFnQixNQUFNLDhCQUE4QixDQUFDOzs7OztBQU1yRjs7Ozs7SUFBMEMsZ0RBQXVCO0lBQWpFOztJQWlKQSxDQUFDO0lBL0lHLGtCQUFrQjs7Ozs7Ozs7SUFDUiw0Q0FBYTs7Ozs7OztJQUF2QixVQUF3QixPQUFvQixFQUFFLFlBQTBCOztZQUM5RCxlQUFlLEdBQWEsRUFBRTtRQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtZQUM3QixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3pCO2lCQUFNOztvQkFDRyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUM7Z0JBQ3hELGVBQWUsQ0FBQyxJQUFJLENBQUMsZ0JBQWMsY0FBYyxRQUFLLENBQUMsQ0FBQzthQUMzRDtTQUNKO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUU7WUFDM0IsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNwQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDdkI7aUJBQU07O29CQUNHLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQztnQkFDcEQsZUFBZSxDQUFDLElBQUksQ0FBQyxnQkFBYyxZQUFZLFFBQUssQ0FBQyxDQUFDO2FBQ3pEO1NBQ0o7UUFFRCxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxlQUFlLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFRDs7OztPQUlHOzs7Ozs7O0lBQ0ssZ0RBQWlCOzs7Ozs7SUFBekIsVUFBMEIsWUFBMEI7Ozs7Ozs7OztZQVExQyxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLG9CQUFvQixHQUFHLENBQUMsQ0FBQzs7WUFDbkUsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRyxDQUFDLENBQUM7O1lBRWpFLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUNqQyxZQUFZLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsQ0FBQzs7WUFDNUYsV0FBVyxHQUFHLFVBQVUsR0FBRyxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSztRQUN0RSxPQUFPLFlBQVksQ0FBQyxZQUFZLENBQUMsSUFBSSxHQUFHLFVBQVUsSUFBSSxXQUFXLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7SUFDeEcsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSyw4Q0FBZTs7Ozs7O0lBQXZCLFVBQXdCLFlBQTBCOztZQUN4QyxpQkFBaUIsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixHQUFHLENBQUMsQ0FBQzs7WUFDakUsZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsR0FBRyxDQUFDLENBQUM7O1lBRS9ELFNBQVMsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUMvQixZQUFZLENBQUMsVUFBVSxFQUFFLFlBQVksQ0FBQyxrQkFBa0IsRUFBRSxpQkFBaUIsRUFBRSxnQkFBZ0IsQ0FBQzs7WUFDNUYsWUFBWSxHQUFHLFNBQVMsR0FBRyxZQUFZLENBQUMsa0JBQWtCLENBQUMsTUFBTTtRQUN2RSxPQUFPLFlBQVksQ0FBQyxZQUFZLENBQUMsR0FBRyxHQUFHLFNBQVMsSUFBSSxZQUFZLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7SUFDeEcsQ0FBQztJQUVEOztPQUVHOzs7Ozs7SUFDSyw2Q0FBYzs7Ozs7SUFBdEI7UUFDSSxRQUFRLElBQUksQ0FBQyxRQUFRLENBQUMsbUJBQW1CLEVBQUU7WUFDdkMsS0FBSyxtQkFBbUIsQ0FBQyxJQUFJO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixHQUFHLG1CQUFtQixDQUFDLEtBQUssQ0FBQztnQkFDOUQsTUFBTTtZQUNWLEtBQUssbUJBQW1CLENBQUMsS0FBSztnQkFDMUIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQyxJQUFJLENBQUM7Z0JBQzdELE1BQU07U0FDYjtRQUNELFFBQVEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsRUFBRTtZQUN4QyxLQUFLLG1CQUFtQixDQUFDLElBQUk7Z0JBQ3pCLElBQUksQ0FBQyxRQUFRLENBQUMsb0JBQW9CLEdBQUcsbUJBQW1CLENBQUMsS0FBSyxDQUFDO2dCQUMvRCxNQUFNO1lBQ1YsS0FBSyxtQkFBbUIsQ0FBQyxLQUFLO2dCQUMxQixJQUFJLENBQUMsUUFBUSxDQUFDLG9CQUFvQixHQUFHLG1CQUFtQixDQUFDLElBQUksQ0FBQztnQkFDOUQsTUFBTTtTQUNiO0lBQ0wsQ0FBQztJQUVEOztPQUVHOzs7Ozs7SUFDSywyQ0FBWTs7Ozs7SUFBcEI7UUFDSSxRQUFRLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEVBQUU7WUFDckMsS0FBSyxpQkFBaUIsQ0FBQyxHQUFHO2dCQUN0QixJQUFJLENBQUMsUUFBUSxDQUFDLGlCQUFpQixHQUFHLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztnQkFDM0QsTUFBTTtZQUNWLEtBQUssaUJBQWlCLENBQUMsTUFBTTtnQkFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxpQkFBaUIsR0FBRyxpQkFBaUIsQ0FBQyxHQUFHLENBQUM7Z0JBQ3hELE1BQU07U0FDYjtRQUNELFFBQVEsSUFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsRUFBRTtZQUN0QyxLQUFLLGlCQUFpQixDQUFDLEdBQUc7Z0JBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEdBQUcsaUJBQWlCLENBQUMsTUFBTSxDQUFDO2dCQUM1RCxNQUFNO1lBQ1YsS0FBSyxpQkFBaUIsQ0FBQyxNQUFNO2dCQUN6QixJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixHQUFHLGlCQUFpQixDQUFDLEdBQUcsQ0FBQztnQkFDekQsTUFBTTtTQUNiO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSyw2Q0FBYzs7Ozs7O0lBQXRCLFVBQXVCLFlBQTBCOztZQUN2QyxVQUFVLEdBQUcsWUFBWSxDQUFDLElBQUk7O1lBQzlCLFdBQVcsR0FBRyxZQUFZLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsS0FBSztRQUN4RSxxR0FBcUc7UUFDckcsdUNBQXVDO1FBQ3ZDLG1HQUFtRztRQUNuRyxxR0FBcUc7UUFDckcsNEJBQTRCO1FBQzVCLElBQUksVUFBVSxHQUFHLENBQUMsRUFBRTtZQUNoQixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDL0I7YUFBTSxJQUFJLFdBQVcsR0FBRyxDQUFDLEVBQUU7WUFDeEIsT0FBTyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLFVBQVUsQ0FBQyxDQUFDO1NBQzlDO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSywyQ0FBWTs7Ozs7O0lBQXBCLFVBQXFCLFlBQTBCOztZQUNyQyxTQUFTLEdBQUcsWUFBWSxDQUFDLEdBQUc7O1lBQzVCLFlBQVksR0FBRyxZQUFZLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTTtRQUMzRSxJQUFJLFNBQVMsR0FBRyxDQUFDLEVBQUU7WUFDZixPQUFPLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDOUI7YUFBTSxJQUFJLFlBQVksR0FBRyxDQUFDLEVBQUU7WUFDekIsT0FBTyxDQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1NBQzlDO2FBQU07WUFDSCxPQUFPLENBQUMsQ0FBQztTQUNaO0lBQ0wsQ0FBQztJQUNMLDJCQUFDO0FBQUQsQ0FBQyxBQWpKRCxDQUEwQyx1QkFBdUIsR0FpSmhFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVydGljYWxBbGlnbm1lbnQsIEhvcml6b250YWxBbGlnbm1lbnQgfSBmcm9tICcuLy4uL3V0aWxpdGllcyc7XG5pbXBvcnQgeyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSwgQ29ubmVjdGVkRml0IH0gZnJvbSAnLi9iYXNlLWZpdC1wb3NpdGlvbi1zdHJhdGVneSc7XG5cbi8qKlxuICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFzIGluICoqQ29ubmVjdGVkKiogcG9zaXRpb25pbmcgc3RyYXRlZ3kgYW5kIHJlLXBvc2l0aW9ucyB0aGUgZWxlbWVudCBpblxuICogdGhlIHZpZXcgcG9ydCAoY2FsY3VsYXRpbmcgYSBkaWZmZXJlbnQgc3RhcnQgcG9pbnQpIGluIGNhc2UgdGhlIGVsZW1lbnQgaXMgcGFydGlhbGx5IGdldHRpbmcgb3V0IG9mIHZpZXdcbiAqL1xuZXhwb3J0IGNsYXNzIEF1dG9Qb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQmFzZUZpdFBvc2l0aW9uU3RyYXRlZ3kge1xuXG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybVN0cmluZzogc3RyaW5nW10gPSBbXTtcbiAgICAgICAgaWYgKCFjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuRmxpcEhvcml6b250YWwoY29ubmVjdGVkRml0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpcEhvcml6b250YWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaG9yaXpvbnRhbFB1c2ggPSB0aGlzLmhvcml6b250YWxQdXNoKGNvbm5lY3RlZEZpdCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVgoJHtob3Jpem9udGFsUHVzaH1weClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY29ubmVjdGVkRml0LmZpdFZlcnRpY2FsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwVmVydGljYWwoY29ubmVjdGVkRml0KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmxpcFZlcnRpY2FsKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnRpY2FsUHVzaCA9IHRoaXMudmVydGljYWxQdXNoKGNvbm5lY3RlZEZpdCk7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVkoJHt2ZXJ0aWNhbFB1c2h9cHgpYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVN0cmluZy5qb2luKCcgJykudHJpbSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBlbGVtZW50IGNhbiBiZSBmbGlwcGVkIHdpdGhvdXQgZ2V0IG9mZiB0aGUgdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyB0cnVlIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgYW5kIHN0YWluIGluIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSBjYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICAvLyAgSG9yaXpvbnRhbEFsaWdubWVudCBjYW4gYmUgTGVmdCA9IC0xOyBDZW50ZXIgPSAtMC41IG9yIFJpZ2h0ID0gMC5cbiAgICAgICAgLy8gIFRvIHZpcnR1YWxseSBmbGlwIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgKGJvdGggYXJlIEhvcml6b250YWxBbGlnbm1lbnQpIHdlIGNhbiBkbyB0aGlzOlxuICAgICAgICAvLyAgZmxpcHBlZEFsaWdubWVudCA9ICgtMSkgKiAoSG9yaXpvbnRhbEFsaWdubWVudCArIDEpXG4gICAgICAgIC8vICB0aGlzIHdheTpcbiAgICAgICAgLy8gICgtMSkgKiAoTGVmdCArIDEpID0gMCA9IFJpZ2h0XG4gICAgICAgIC8vICAoLTEpICogKENlbnRlciArIDEpID0gLTAuNSA9IENlbnRlclxuICAgICAgICAvLyAgKC0xKSAqIChSaWdodCArIDEpID0gLTEgPSBMZWZ0XG4gICAgICAgIGNvbnN0IGZsaXBwZWRTdGFydFBvaW50ID0gKC0xKSAqICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50ICsgMSk7XG4gICAgICAgIGNvbnN0IGZsaXBwZWREaXJlY3Rpb24gPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IGxlZnRCb3JkZXIgPSB0aGlzLmNhbGN1bGF0ZUxlZnQoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCwgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdCwgZmxpcHBlZFN0YXJ0UG9pbnQsIGZsaXBwZWREaXJlY3Rpb24pO1xuICAgICAgICBjb25zdCByaWdodEJvcmRlciA9IGxlZnRCb3JkZXIgKyBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICByZXR1cm4gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5sZWZ0IDwgbGVmdEJvcmRlciAmJiByaWdodEJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QucmlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbGlwcGVkU3RhcnRQb2ludCA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsIGZsaXBwZWRTdGFydFBvaW50LCBmbGlwcGVkRGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgYm90dG9tQm9yZGVyID0gdG9wQm9yZGVyICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LnRvcCA8IHRvcEJvcmRlciAmJiBib3R0b21Cb3JkZXIgPCBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LmJvdHRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGlwcyBkaXJlY3Rpb24gYW5kIHN0YXJ0IHBvaW50IG9mIHRoZSBwb3NpdGlvbiBzZXR0aW5nc1xuICAgICAqL1xuICAgIHByaXZhdGUgZmxpcEhvcml6b250YWwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24gPSBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQpIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgPSBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LlJpZ2h0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgPSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbGlwcyBkaXJlY3Rpb24gYW5kIHN0YXJ0IHBvaW50IG9mIHRoZSBwb3NpdGlvbiBzZXR0aW5nc1xuICAgICAqL1xuICAgIHByaXZhdGUgZmxpcFZlcnRpY2FsKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuVG9wOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsRGlyZWN0aW9uID0gVmVydGljYWxBbGlnbm1lbnQuVG9wO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQpIHtcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuVG9wOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxTdGFydFBvaW50ID0gVmVydGljYWxBbGlnbm1lbnQuQm90dG9tO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b206XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG5lY2Vzc2FyeSBob3Jpem9udGFsIHB1c2ggYWNjb3JkaW5nIHRvIHByb3ZpZGVkIGNvbm5lY3RlZEZpdFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIGFtb3VudCBvZiBuZWNlc3NhcnkgdHJhbnNsYXRpb24gd2hpY2ggd2lsbCBwdXNoIHRoZSBlbGVtZW50IGludG8gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGhvcml6b250YWxQdXNoKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgbGVmdEV4dGVuZCA9IGNvbm5lY3RlZEZpdC5sZWZ0O1xuICAgICAgICBjb25zdCByaWdodEV4dGVuZCA9IGNvbm5lY3RlZEZpdC5yaWdodCAtIGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QucmlnaHQ7XG4gICAgICAgIC8vICBpZiBsZWZ0RXh0ZW5kIDwgMCBvdmVybGF5IGdvZXMgYmV5b25kIGxlZnQgZW5kIG9mIHRoZSBzY3JlZW4uIFdlIHNob3VsZCBwdXNoIGl0IGJhY2sgd2l0aCBleGFjdGx5XG4gICAgICAgIC8vICBhcyBtdWNoIGFzIGl0IGlzIGJleW9uZCB0aGUgc2NyZWVuLlxuICAgICAgICAvLyAgaWYgcmlnaHRFeHRlbmQgPiAwIG92ZXJsYXkgZ29lcyBiZXlvbmQgcmlnaHQgZW5kIG9mIHRoZSBzY3JlZW4uIFdlIHNob3VsZCBwdXNoIGl0IGJhY2sgd2l0aCB0aGVcbiAgICAgICAgLy8gIGV4dGVuZCBidXQgd2l0aCBhbW91bnQgbm90IGJpZ2dlciB0aGFuIHdoYXQgbGVmdCBiZXR3ZWVuIGxlZnQgYm9yZGVyIG9mIHNjcmVlbiBhbmQgbGVmdCBib3JkZXIgb2ZcbiAgICAgICAgLy8gIG92ZXJsYXksIGUuZy4gbGVmdEV4dGVuZFxuICAgICAgICBpZiAobGVmdEV4dGVuZCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmFicyhsZWZ0RXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChyaWdodEV4dGVuZCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiAtIE1hdGgubWluKHJpZ2h0RXh0ZW5kLCBsZWZ0RXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyBuZWNlc3NhcnkgdmVydGljYWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgYW1vdW50IG9mIG5lY2Vzc2FyeSB0cmFuc2xhdGlvbiB3aGljaCB3aWxsIHB1c2ggdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgdmVydGljYWxQdXNoKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogbnVtYmVyIHtcbiAgICAgICAgY29uc3QgdG9wRXh0ZW5kID0gY29ubmVjdGVkRml0LnRvcDtcbiAgICAgICAgY29uc3QgYm90dG9tRXh0ZW5kID0gY29ubmVjdGVkRml0LmJvdHRvbSAtIGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuYm90dG9tO1xuICAgICAgICBpZiAodG9wRXh0ZW5kIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSBpZiAoYm90dG9tRXh0ZW5kID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0gTWF0aC5taW4oYm90dG9tRXh0ZW5kLCB0b3BFeHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=