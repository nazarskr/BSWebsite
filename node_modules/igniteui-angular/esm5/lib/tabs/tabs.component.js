/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, forwardRef, HostBinding, Input, NgModule, Output, QueryList, ViewChild, ViewChildren, NgZone } from '@angular/core';
import { IgxBadgeModule } from '../badge/badge.component';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxIconModule } from '../icon/index';
import { IgxTabItemComponent } from './tab-item.component';
import { IgxTabsGroupComponent } from './tabs-group.component';
import { IgxLeftButtonStyleDirective, IgxRightButtonStyleDirective, IgxTabItemTemplateDirective } from './tabs.directives';
import { IgxTabsBase } from './tabs.common';
import ResizeObserver from 'resize-observer-polyfill';
/** @enum {string} */
var TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
export { TabsType };
var IgxTabsComponent = /** @class */ (function () {
    function IgxTabsComponent(_element, _ngZone) {
        this._element = _element;
        this._ngZone = _ngZone;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    Object.defineProperty(IgxTabsComponent.prototype, "selectedIndex", {
        /**
        * An @Input property that sets the value of the `selectedIndex`.
        * Default value is 0.
        * ```html
        * <igx-tabs selectedIndex="1">
        * ```
        *
        * Two-way data binding.
        * ```html
        * <igx-tabs [(selectedIndex)]="model.selectedIndex">
        * ```
        */
        get: /**
         * An \@Input property that sets the value of the `selectedIndex`.
         * Default value is 0.
         * ```html
         * <igx-tabs selectedIndex="1">
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-tabs [(selectedIndex)]="model.selectedIndex">
         * ```
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
            if (this._selectedIndex !== newIndex) {
                if (this.tabs && this.tabs.length > 0) {
                    /** @type {?} */
                    var newTab = this.tabs.toArray()[newIndex];
                    if (newTab) {
                        this.performSelectionChange(newTab);
                    }
                }
                else {
                    this._selectedIndex = newIndex;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "tabs", {
        /**
         * Provides an observable collection of all `IgxTabItemComponent`s.
         * First try to get them as content children if not available get them as view children.
         * ```typescript
         * const tabItems = this.myTabComponent.tabs;
         * ```
         */
        get: /**
         * Provides an observable collection of all `IgxTabItemComponent`s.
         * First try to get them as content children if not available get them as view children.
         * ```typescript
         * const tabItems = this.myTabComponent.tabs;
         * ```
         * @return {?}
         */
        function () {
            if (this.hasContentTabs) {
                return this.contentTabs;
            }
            return this.viewTabs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "hasContentTabs", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return (this.contentTabs && this.contentTabs.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "cssClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultStyle = "igx-tabs";
            /** @type {?} */
            var fixedStyle = "igx-tabs--fixed";
            /** @type {?} */
            var iconStyle = "igx-tabs--icons";
            /** @type {?} */
            var iconLabelFoundInGroups = this.groups.find(function (group) { return group.icon != null && group.label != null; });
            /** @type {?} */
            var iconLabelFoundInTabs = this.contentTabs.find(function (tab) { return tab.icon != null && tab.label != null; });
            /** @type {?} */
            var css;
            switch (TabsType[this.tabsType.toUpperCase()]) {
                case TabsType.FIXED: {
                    css = fixedStyle;
                    break;
                }
                default: {
                    css = defaultStyle;
                    break;
                }
            }
            // Layout fix for items with icons
            if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
                css = css + " " + iconStyle;
            }
            return css + " " + this.class;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollElement = /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    function (element, scrollRight) {
        /** @type {?} */
        var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = "translate(" + -this.offset + "px)";
    };
    Object.defineProperty(IgxTabsComponent.prototype, "selectedTabItem", {
        /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         */
        get: /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         * @return {?}
         */
        function () {
            if (this.tabs && this.selectedIndex !== undefined) {
                return this.tabs.toArray()[this.selectedIndex];
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._selectedIndex === -1) {
            this.tabs.forEach(function (t) {
                if (t.isSelected) {
                    _this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        requestAnimationFrame(function () {
            /** @type {?} */
            var newTab = _this.tabs.toArray()[_this._selectedIndex];
            if (newTab) {
                _this.performSelection(newTab);
            }
            else {
                _this.hideIndicator();
            }
        });
        this._groupChanges$ = this.groups.changes.subscribe(function () {
            _this.resetSelectionOnCollectionChanged();
        });
        this._ngZone.runOutsideAngular(function () {
            _this._resizeObserver = new ResizeObserver(function () {
                if (!_this.hasContentTabs && _this._selectedIndex >= 0 && _this._selectedIndex < _this.tabs.length) {
                    /** @type {?} */
                    var newTab = _this.tabs.toArray()[_this._selectedIndex];
                    _this.transformContentAnimation(newTab, 0);
                }
            });
            _this._resizeObserver.observe(_this.tabsContainer.nativeElement);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        this._ngZone.runOutsideAngular(function () {
            _this._resizeObserver.disconnect();
        });
    };
    /**
     * @private
     * @return {?}
     */
    IgxTabsComponent.prototype.resetSelectionOnCollectionChanged = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            /** @type {?} */
            var currentTab = _this.tabs.toArray()[_this.selectedIndex];
            if (currentTab) {
                _this.performSelectionChange(currentTab);
            }
            else if (_this.selectedIndex >= _this.tabs.length) {
                _this.performSelectionChange(_this.tabs.last);
            }
            else {
                _this.hideIndicator();
            }
        });
    };
    /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scroll = /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    function (scrollRight) {
        var e_1, _a;
        /** @type {?} */
        var tabsArray = this.tabs.toArray();
        try {
            for (var tabsArray_1 = tslib_1.__values(tabsArray), tabsArray_1_1 = tabsArray_1.next(); !tabsArray_1_1.done; tabsArray_1_1 = tabsArray_1.next()) {
                var tab = tabsArray_1_1.value;
                /** @type {?} */
                var element = tab.nativeTabItem.nativeElement;
                if (scrollRight) {
                    if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
                else {
                    if (element.offsetWidth + element.offsetLeft >= this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tabsArray_1_1 && !tabsArray_1_1.done && (_a = tabsArray_1.return)) _a.call(tabsArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performSelectionChange = /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        /** @type {?} */
        var oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    };
    /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performDeselection = /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    function (oldTab) {
        oldTab.setSelectedInternal(false);
        /** @type {?} */
        var oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    };
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performSelection = /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        var _this = this;
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        /** @type {?} */
        var newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(function () {
            // bring the new selected tab into view if it is not
            _this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            _this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!_this.hasContentTabs) {
                _this.transformContentAnimation(newTab, 0.2);
            }
        });
    };
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.bringNewTabIntoView = /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        /** @type {?} */
        var tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        /** @type {?} */
        var viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        /** @type {?} */
        var delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    };
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    IgxTabsComponent.prototype.transformContentAnimation = /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    function (tab, duration) {
        /** @type {?} */
        var contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
        this.contentsContainer.nativeElement.style.transform = "translate(" + -contentOffset + "px)";
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    IgxTabsComponent.prototype.transformIndicatorAnimation = /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    function (element, duration) {
        if (duration === void 0) { duration = 0.3; }
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
            this.selectedIndicator.nativeElement.style.width = element.offsetWidth + "px";
            this.selectedIndicator.nativeElement.style.transform = "translate(" + element.offsetLeft + "px)";
        }
    };
    /**
     * @return {?}
     */
    IgxTabsComponent.prototype.hideIndicator = /**
     * @return {?}
     */
    function () {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    };
    IgxTabsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tabs',
                    template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
                    providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxTabsComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    IgxTabsComponent.propDecorators = {
        groups: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabsGroupComponent; }),] }],
        contentTabs: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabItemComponent; }),] }],
        selectedIndex: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        tabsType: [{ type: Input, args: ['tabsType',] }],
        class: [{ type: Input }],
        onTabItemDeselected: [{ type: Output }],
        onTabItemSelected: [{ type: Output }],
        contentsContainer: [{ type: ViewChild, args: ['contentsContainer', { static: true },] }],
        headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
        itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
        selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator', { static: false },] }],
        tabsContainer: [{ type: ViewChild, args: ['tabsContainer', { static: true },] }],
        viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
        viewTabs: [{ type: ViewChildren, args: [forwardRef(function () { return IgxTabItemComponent; }),] }],
        cssClass: [{ type: HostBinding, args: ['attr.class',] }]
    };
    return IgxTabsComponent;
}());
export { IgxTabsComponent };
if (false) {
    /**
     * Provides an observable collection of all `IgxTabsGroupComponent`s.
     * ```typescript
     * const groupItems = this.myTabComponent.groups;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.groups;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s defined in the page.
     * ```typescript
     * const tabItems = this.myTabComponent.contentTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.contentTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndexChange;
    /**
     * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
     * By default the header sizing mode is `contentfit`.
     * ```html
     * <igx-tabs tabsType="fixed">
     *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
     * </igx-tabs>
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsType;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.class;
    /**
     * Emitted when a tab item is deselected.
     * ```html
     * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemDeselected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemDeselected;
    /**
     * Emitted when a tab item is selected.
     * ```html
     * <igx-tabs (onTabItemSelected)="itemSelected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemSelected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemSelected;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.contentsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.headerContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.itemsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndicator;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.viewPort;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * ```typescript
     * const tabItems = this.myTabComponent.viewTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.viewTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.calculatedWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.visibleItemsWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.offset;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._groupChanges$;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._element;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._ngZone;
}
/**
 * @hidden
 */
var IgxTabsModule = /** @class */ (function () {
    function IgxTabsModule() {
    }
    IgxTabsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    exports: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
                },] }
    ];
    return IgxTabsModule;
}());
export { IgxTabsModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3RhYnMvdGFicy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUVILFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUVaLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDL0QsT0FBTyxFQUFFLDJCQUEyQixFQUFFLDRCQUE0QixFQUFFLDJCQUEyQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0gsT0FBTyxFQUFFLFdBQVcsRUFBa0IsTUFBTSxlQUFlLENBQUM7QUFDNUQsT0FBTyxjQUFjLE1BQU0sMEJBQTBCLENBQUM7OztJQUdsRCxPQUFRLE9BQU87SUFDZixZQUFhLFlBQVk7OztBQUc3QjtJQTJRSSwwQkFBb0IsUUFBb0IsRUFBVSxPQUFlO1FBQTdDLGFBQVEsR0FBUixRQUFRLENBQVk7UUFBVSxZQUFPLEdBQVAsT0FBTyxDQUFROzs7O1FBL00xRCx3QkFBbUIsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDOzs7Ozs7Ozs7O1FBWWpELGFBQVEsR0FBc0Is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Ozs7SUFLbkMsMENBQ2tDOzs7OztJQUtsQyw2Q0FDcUM7Ozs7O0lBS3JDLHlDQUNpQzs7Ozs7SUFLakMsb0NBQzRCOzs7Ozs7OztJQVE1QixvQ0FDZ0Q7Ozs7O0lBMEJoRCwyQ0FBK0I7Ozs7O0lBSy9CLDZDQUFpQzs7Ozs7SUFLakMsa0NBQWtCOzs7OztJQUVsQiwwQ0FBcUM7Ozs7O0lBQ3JDLDBDQUE0Qjs7Ozs7SUFDNUIsMkNBQXdDOzs7OztJQW9FNUIsb0NBQTRCOzs7OztJQUFFLG1DQUF1Qjs7Ozs7QUFnTXJFO0lBQUE7SUFpQkEsQ0FBQzs7Z0JBakJBLFFBQVEsU0FBQztvQkFDTixZQUFZLEVBQUUsQ0FBQyxnQkFBZ0I7d0JBQzNCLHFCQUFxQjt3QkFDckIsbUJBQW1CO3dCQUNuQiwyQkFBMkI7d0JBQzNCLDRCQUE0Qjt3QkFDNUIsMkJBQTJCLENBQUM7b0JBQ2hDLE9BQU8sRUFBRSxDQUFDLGdCQUFnQjt3QkFDdEIscUJBQXFCO3dCQUNyQixtQkFBbUI7d0JBQ25CLDJCQUEyQjt3QkFDM0IsNEJBQTRCO3dCQUM1QiwyQkFBMkIsQ0FBQztvQkFDaEMsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxDQUFDO2lCQUMxRTs7SUFHRCxvQkFBQztDQUFBLEFBakJELElBaUJDO1NBRFksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBPbkRlc3Ryb3ksXG4gICAgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJZ3hCYWRnZU1vZHVsZSB9IGZyb20gJy4uL2JhZGdlL2JhZGdlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVNb2R1bGUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEljb25Nb2R1bGUgfSBmcm9tICcuLi9pY29uL2luZGV4JztcbmltcG9ydCB7IElneFRhYkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3RhYi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUYWJzR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL3RhYnMtZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJzLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4VGFic0Jhc2UsIElneFRhYkl0ZW1CYXNlIH0gZnJvbSAnLi90YWJzLmNvbW1vbic7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcblxuZXhwb3J0IGVudW0gVGFic1R5cGUge1xuICAgIEZJWEVEID0gJ2ZpeGVkJyxcbiAgICBDT05URU5URklUID0gJ2NvbnRlbnRmaXQnXG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnaWd4LXRhYnMnLFxuICAgIHRlbXBsYXRlVXJsOiAndGFicy5jb21wb25lbnQuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbeyBwcm92aWRlOiBJZ3hUYWJzQmFzZSwgdXNlRXhpc3Rpbmc6IElneFRhYnNDb21wb25lbnQgfV1cbn0pXG5cbmV4cG9ydCBjbGFzcyBJZ3hUYWJzQ29tcG9uZW50IGltcGxlbWVudHMgSWd4VGFic0Jhc2UsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqXG4gICAgKiBQcm92aWRlcyBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgYWxsIGBJZ3hUYWJzR3JvdXBDb21wb25lbnRgcy5cbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIGNvbnN0IGdyb3VwSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50Lmdyb3VwcztcbiAgICAqIGBgYFxuICAgICovXG4gICAgQENvbnRlbnRDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IElneFRhYnNHcm91cENvbXBvbmVudCkpXG4gICAgcHVibGljIGdyb3VwczogUXVlcnlMaXN0PElneFRhYnNHcm91cENvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYkl0ZW1Db21wb25lbnRgcyBkZWZpbmVkIGluIHRoZSBwYWdlLlxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogY29uc3QgdGFiSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50LmNvbnRlbnRUYWJzO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gSWd4VGFiSXRlbUNvbXBvbmVudCkpXG4gICAgcHVibGljIGNvbnRlbnRUYWJzOiBRdWVyeUxpc3Q8SWd4VGFiSXRlbUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgc2VsZWN0ZWRJbmRleGAuXG4gICAgKiBEZWZhdWx0IHZhbHVlIGlzIDAuXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LXRhYnMgc2VsZWN0ZWRJbmRleD1cIjFcIj5cbiAgICAqIGBgYFxuICAgICpcbiAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICogYGBgaHRtbFxuICAgICogPGlneC10YWJzIFsoc2VsZWN0ZWRJbmRleCldPVwibW9kZWwuc2VsZWN0ZWRJbmRleFwiPlxuICAgICogYGBgXG4gICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgc2VsZWN0ZWRJbmRleCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VsZWN0ZWRJbmRleDtcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IHNlbGVjdGVkSW5kZXgoaW5kZXg6IG51bWJlcikge1xuICAgICAgICBjb25zdCBuZXdJbmRleCA9IHR5cGVvZiBpbmRleCAhPT0gJ251bWJlcicgPyBwYXJzZUludChpbmRleCwgMTApIDogaW5kZXg7XG4gICAgICAgIGlmICh0aGlzLl9zZWxlY3RlZEluZGV4ICE9PSBuZXdJbmRleCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFicyAmJiB0aGlzLnRhYnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbbmV3SW5kZXhdO1xuICAgICAgICAgICAgICAgIGlmIChuZXdUYWIpIHtcbiAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb25DaGFuZ2UobmV3VGFiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBuZXdJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBzZWxlY3RlZEluZGV4Q2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxudW1iZXI+KCk7XG5cbiAgICAvKipcbiAgICAgKiBEZWZpbmVzIHRoZSB0YWIgaGVhZGVyIHNpemluZyBtb2RlLiBZb3UgY2FuIGNob29zZSBiZXR3ZWVuIGBjb250ZW50Zml0YCBvciBgZml4ZWRgLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGhlYWRlciBzaXppbmcgbW9kZSBpcyBgY29udGVudGZpdGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdGFicyB0YWJzVHlwZT1cImZpeGVkXCI+XG4gICAgICogICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIkhPTUVcIj5Ib21lPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiA8L2lneC10YWJzPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgndGFic1R5cGUnKVxuICAgIHB1YmxpYyB0YWJzVHlwZTogc3RyaW5nIHwgVGFic1R5cGUgPSAnY29udGVudGZpdCc7XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGNsYXNzID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIHdoZW4gYSB0YWIgaXRlbSBpcyBkZXNlbGVjdGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRhYnMgKG9uVGFiSXRlbURlc2VsZWN0ZWQpPVwiaXRlbURlc2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDFcIj5UaGlzIGlzIFRhYiAxIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiAgICAgIDxpZ3gtdGFicy1ncm91cCBsYWJlbD1cIlRhYiAyXCI+VGhpcyBpcyBUYWIgMiBjb250ZW50LjwvaWd4LXRhYnMtZ3JvdXA+XG4gICAgICogPC9pZ3gtdGFicz5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaXRlbURlc2VsZWN0ZWQoZSl7XG4gICAgICogICAgICBjb25zdCB0YWJHcm91cCA9IGUuZ3JvdXA7XG4gICAgICogICAgICBjb25zdCB0YWJJdGVtID0gZS50YWI7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblRhYkl0ZW1EZXNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgKiBFbWl0dGVkIHdoZW4gYSB0YWIgaXRlbSBpcyBzZWxlY3RlZC5cbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtdGFicyAob25UYWJJdGVtU2VsZWN0ZWQpPVwiaXRlbVNlbGVjdGVkKCRldmVudClcIj5cbiAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDFcIj5UaGlzIGlzIFRhYiAxIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDJcIj5UaGlzIGlzIFRhYiAyIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAqIDwvaWd4LXRhYnM+XG4gICAgKiBgYGBcbiAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAqIGl0ZW1TZWxlY3RlZChlKXtcbiAgICAqICAgICAgY29uc3QgdGFiR3JvdXAgPSBlLmdyb3VwO1xuICAgICogICAgICBjb25zdCB0YWJJdGVtID0gZS50YWI7XG4gICAgKiB9XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblRhYkl0ZW1TZWxlY3RlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdjb250ZW50c0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGNvbnRlbnRzQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2hlYWRlckNvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGhlYWRlckNvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdpdGVtc0NvbnRhaW5lcicsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIGl0ZW1zQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3NlbGVjdGVkSW5kaWNhdG9yJywgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHVibGljIHNlbGVjdGVkSW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBAVmlld0NoaWxkKCd0YWJzQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdGFic0NvbnRhaW5lcjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCd2aWV3UG9ydCcsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHVibGljIHZpZXdQb3J0OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFiSXRlbUNvbXBvbmVudGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0YWJJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQudmlld1RhYnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQFZpZXdDaGlsZHJlbihmb3J3YXJkUmVmKCgpID0+IElneFRhYkl0ZW1Db21wb25lbnQpKVxuICAgIHB1YmxpYyB2aWV3VGFiczogUXVlcnlMaXN0PElneFRhYkl0ZW1Db21wb25lbnQ+O1xuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFiSXRlbUNvbXBvbmVudGBzLlxuICAgICAqIEZpcnN0IHRyeSB0byBnZXQgdGhlbSBhcyBjb250ZW50IGNoaWxkcmVuIGlmIG5vdCBhdmFpbGFibGUgZ2V0IHRoZW0gYXMgdmlldyBjaGlsZHJlbi5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3QgdGFiSXRlbXMgPSB0aGlzLm15VGFiQ29tcG9uZW50LnRhYnM7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB0YWJzKCk6IFF1ZXJ5TGlzdDxJZ3hUYWJJdGVtQ29tcG9uZW50PiB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbnRlbnRUYWJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50VGFicztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3VGFicztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0NvbnRlbnRUYWJzKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29udGVudFRhYnMgJiYgdGhpcy5jb250ZW50VGFicy5sZW5ndGggPiAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGNhbGN1bGF0ZWRXaWR0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB2aXNpYmxlSXRlbXNXaWR0aDogbnVtYmVyO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvZmZzZXQgPSAwO1xuXG4gICAgcHJpdmF0ZSBfZ3JvdXBDaGFuZ2VzJDogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX3NlbGVjdGVkSW5kZXggPSAtMTtcbiAgICBwcml2YXRlIF9yZXNpemVPYnNlcnZlcjogUmVzaXplT2JzZXJ2ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmNsYXNzJylcbiAgICBwdWJsaWMgZ2V0IGNzc0NsYXNzKCkge1xuICAgICAgICBjb25zdCBkZWZhdWx0U3R5bGUgPSBgaWd4LXRhYnNgO1xuICAgICAgICBjb25zdCBmaXhlZFN0eWxlID0gYGlneC10YWJzLS1maXhlZGA7XG4gICAgICAgIGNvbnN0IGljb25TdHlsZSA9IGBpZ3gtdGFicy0taWNvbnNgO1xuICAgICAgICBjb25zdCBpY29uTGFiZWxGb3VuZEluR3JvdXBzID0gdGhpcy5ncm91cHMuZmluZCgoZ3JvdXApID0+IGdyb3VwLmljb24gIT0gbnVsbCAmJiBncm91cC5sYWJlbCAhPSBudWxsKTtcbiAgICAgICAgY29uc3QgaWNvbkxhYmVsRm91bmRJblRhYnMgPSB0aGlzLmNvbnRlbnRUYWJzLmZpbmQoKHRhYikgPT4gdGFiLmljb24gIT0gbnVsbCAmJiB0YWIubGFiZWwgIT0gbnVsbCk7XG4gICAgICAgIGxldCBjc3M7XG4gICAgICAgIHN3aXRjaCAoVGFic1R5cGVbdGhpcy50YWJzVHlwZS50b1VwcGVyQ2FzZSgpXSkge1xuICAgICAgICAgICAgY2FzZSBUYWJzVHlwZS5GSVhFRDoge1xuICAgICAgICAgICAgICAgIGNzcyA9IGZpeGVkU3R5bGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgY3NzID0gZGVmYXVsdFN0eWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGF5b3V0IGZpeCBmb3IgaXRlbXMgd2l0aCBpY29uc1xuICAgICAgICBpZiAoaWNvbkxhYmVsRm91bmRJbkdyb3VwcyAhPT0gdW5kZWZpbmVkIHx8IGljb25MYWJlbEZvdW5kSW5UYWJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNzcyA9IGAke2Nzc30gJHtpY29uU3R5bGV9YDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHtjc3N9ICR7dGhpcy5jbGFzc31gO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsTGVmdChldmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxSaWdodChldmVudCk6IHZvaWQge1xuICAgICAgICB0aGlzLnNjcm9sbCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbEVsZW1lbnQoZWxlbWVudDogYW55LCBzY3JvbGxSaWdodDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCB2aWV3UG9ydFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIHRoaXMub2Zmc2V0ID0gKHNjcm9sbFJpZ2h0KSA/IGVsZW1lbnQub2Zmc2V0V2lkdGggKyBlbGVtZW50Lm9mZnNldExlZnQgLSB2aWV3UG9ydFdpZHRoIDogZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICB0aGlzLml0ZW1zQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgkey10aGlzLm9mZnNldH1weClgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHNlbGVjdGVkIGBJZ3hUYWJJdGVtQ29tcG9uZW50YC5cbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBzZWxlY3RlZEl0ZW0gPSB0aGlzLm15VGFiQ29tcG9uZW50LnNlbGVjdGVkVGFiSXRlbTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgc2VsZWN0ZWRUYWJJdGVtKCk6IElneFRhYkl0ZW1Db21wb25lbnQge1xuICAgICAgICBpZiAodGhpcy50YWJzICYmIHRoaXMuc2VsZWN0ZWRJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50YWJzLnRvQXJyYXkoKVt0aGlzLnNlbGVjdGVkSW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBfZWxlbWVudDogRWxlbWVudFJlZiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnRhYnMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0LmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IHQuaW5kZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgKHRoaXMuc2VsZWN0ZWRJbmRleCA8IDAgfHwgdGhpcy5zZWxlY3RlZEluZGV4ID49IHRoaXMuZ3JvdXBzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5fc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICBpZiAobmV3VGFiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uKG5ld1RhYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUluZGljYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9ncm91cENoYW5nZXMkID0gdGhpcy5ncm91cHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk9uQ29sbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fbmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCA+PSAwICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggPCB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5fc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGVudEFuaW1hdGlvbihuZXdUYWIsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMudGFic0NvbnRhaW5lci5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwQ2hhbmdlcyQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXRTZWxlY3Rpb25PbkNvbGxlY3Rpb25DaGFuZ2VkKCk6IHZvaWQge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5zZWxlY3RlZEluZGV4XTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VGFiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtU2VsZWN0aW9uQ2hhbmdlKGN1cnJlbnRUYWIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy50YWJzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZSh0aGlzLnRhYnMubGFzdCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUluZGljYXRvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNjcm9sbChzY3JvbGxSaWdodDogYm9vbGVhbik6IHZvaWQge1xuICAgICAgICBjb25zdCB0YWJzQXJyYXkgPSB0aGlzLnRhYnMudG9BcnJheSgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRhYiBvZiB0YWJzQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0YWIubmF0aXZlVGFiSXRlbS5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgaWYgKHNjcm9sbFJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQub2Zmc2V0V2lkdGggKyBlbGVtZW50Lm9mZnNldExlZnQgPiB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKyB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0ID49IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudChlbGVtZW50LCBzY3JvbGxSaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgcGVyZm9ybVNlbGVjdGlvbkNoYW5nZShuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IG9sZFRhYiA9IHRoaXMuc2VsZWN0ZWRUYWJJdGVtO1xuICAgICAgICBpZiAob2xkVGFiKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1EZXNlbGVjdGlvbihvbGRUYWIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdUYWIpIHtcbiAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbihuZXdUYWIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gbmV3IHNlbGVjdGVkIHRhYiBoaWRlIHRoZSBzZWxlY3Rpb24gaW5kaWNhdG9yXG4gICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGVkSW5kZXhDaGFuZ2UuZW1pdCh0aGlzLl9zZWxlY3RlZEluZGV4KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHBlcmZvcm1EZXNlbGVjdGlvbihvbGRUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIG9sZFRhYi5zZXRTZWxlY3RlZEludGVybmFsKGZhbHNlKTtcbiAgICAgICAgY29uc3Qgb2xkVGFiUmVsYXRlZEdyb3VwID0gdGhpcy5ncm91cHMudG9BcnJheSgpW29sZFRhYi5pbmRleF07XG4gICAgICAgIGlmIChvbGRUYWJSZWxhdGVkR3JvdXApIHtcbiAgICAgICAgICAgIG9sZFRhYlJlbGF0ZWRHcm91cC5zZXRTZWxlY3RlZEludGVybmFsKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMub25UYWJJdGVtRGVzZWxlY3RlZC5lbWl0KHsgdGFiOiBvbGRUYWIsIGdyb3VwOiBvbGRUYWJSZWxhdGVkR3JvdXAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwZXJmb3JtU2VsZWN0aW9uKG5ld1RhYjogSWd4VGFiSXRlbUJhc2UpOiB2b2lkIHtcbiAgICAgICAgbmV3VGFiLnNldFNlbGVjdGVkSW50ZXJuYWwodHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGVkSW5kZXggPSBuZXdUYWIuaW5kZXg7XG5cbiAgICAgICAgbGV0IG5ld1RhYlJlbGF0ZWRHcm91cCA9IG51bGw7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicyAmJiB0aGlzLmdyb3Vwcykge1xuICAgICAgICAgICAgbmV3VGFiUmVsYXRlZEdyb3VwID0gdGhpcy5ncm91cHMudG9BcnJheSgpW25ld1RhYi5pbmRleF07XG4gICAgICAgICAgICBpZiAobmV3VGFiUmVsYXRlZEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgbmV3VGFiUmVsYXRlZEdyb3VwLnNldFNlbGVjdGVkSW50ZXJuYWwodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uVGFiSXRlbVNlbGVjdGVkLmVtaXQoeyB0YWI6IG5ld1RhYiwgZ3JvdXA6IG5ld1RhYlJlbGF0ZWRHcm91cCB9KTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgLy8gYnJpbmcgdGhlIG5ldyBzZWxlY3RlZCB0YWIgaW50byB2aWV3IGlmIGl0IGlzIG5vdFxuICAgICAgICAgICAgdGhpcy5icmluZ05ld1RhYkludG9WaWV3KG5ld1RhYik7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBuZXcgc2VsZWN0aW9uIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1JbmRpY2F0b3JBbmltYXRpb24obmV3VGFiLm5hdGl2ZVRhYkl0ZW0ubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICAvLyBhbmltYXRlIHRoZSBuZXcgdGFiJ3MgZ3JvdXAgY29udGVudFxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0NvbnRlbnRUYWJzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKG5ld1RhYiwgMC4yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBicmluZ05ld1RhYkludG9WaWV3KG5ld1RhYjogSWd4VGFiSXRlbUJhc2UpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFiTmF0aXZlRWxlbWVudCA9IG5ld1RhYi5uYXRpdmVUYWJJdGVtLm5hdGl2ZUVsZW1lbnQ7XG5cbiAgICAgICAgLy8gU2Nyb2xsIGxlZnQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICBpZiAodGFiTmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0IDwgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJOYXRpdmVFbGVtZW50LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTY3JvbGwgcmlnaHQgaWYgdGhlcmUgaXMgbmVlZFxuICAgICAgICBjb25zdCB2aWV3UG9ydE9mZnNldFdpZHRoID0gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBkZWx0YSA9ICh0YWJOYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgKyB0YWJOYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoKSAtICh2aWV3UG9ydE9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpO1xuXG4gICAgICAgIC8vIEZpeCBmb3IgSUUgMTEsIGEgZGlmZmVyZW5jZSBpcyBhY2N1bXVsYXRlZCBmcm9tIHRoZSB3aWR0aHMgY2FsY3VsYXRpb25zXG4gICAgICAgIGlmIChkZWx0YSA+IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsRWxlbWVudCh0YWJOYXRpdmVFbGVtZW50LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICAvLyBhbmltYXRpb24gZm9yIHRoZSBuZXcgcGFuZWwvZ3JvdXAgKG5vdCBuZWVkZWQgZm9yIHRhYiBvbmx5IG1vZGUpXG4gICAgcHVibGljIHRyYW5zZm9ybUNvbnRlbnRBbmltYXRpb24odGFiOiBJZ3hUYWJJdGVtQmFzZSwgZHVyYXRpb246IG51bWJlcik6IHZvaWQge1xuICAgICAgICBjb25zdCBjb250ZW50T2Zmc2V0ID0gdGhpcy50YWJzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggKiB0YWIuaW5kZXg7XG4gICAgICAgIHRoaXMuY29udGVudHNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSBkdXJhdGlvbiA+IDAgPyBgJHtkdXJhdGlvbn1zYCA6ICdpbml0aWFsJztcbiAgICAgICAgdGhpcy5jb250ZW50c0NvbnRhaW5lci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IGB0cmFuc2xhdGUoJHstY29udGVudE9mZnNldH1weClgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdHJhbnNmb3JtSW5kaWNhdG9yQW5pbWF0aW9uKGVsZW1lbnQ6IEhUTUxFbGVtZW50LCBkdXJhdGlvbiA9IDAuMyk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEluZGljYXRvcikge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtlbGVtZW50Lm9mZnNldFdpZHRofXB4YDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZWxlbWVudC5vZmZzZXRMZWZ0fXB4KWA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwdWJsaWMgaGlkZUluZGljYXRvcigpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICB9XG5cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4VGFic0NvbXBvbmVudCxcbiAgICAgICAgSWd4VGFic0dyb3VwQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJJdGVtVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFJpZ2h0QnV0dG9uU3R5bGVEaXJlY3RpdmUsXG4gICAgICAgIElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFRhYnNDb21wb25lbnQsXG4gICAgICAgIElneFRhYnNHcm91cENvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbUNvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmVdLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIElneEJhZGdlTW9kdWxlLCBJZ3hJY29uTW9kdWxlLCBJZ3hSaXBwbGVNb2R1bGVdXG59KVxuXG5leHBvcnQgY2xhc3MgSWd4VGFic01vZHVsZSB7XG59XG4iXX0=