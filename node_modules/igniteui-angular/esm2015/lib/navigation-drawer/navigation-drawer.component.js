/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, Renderer, ViewChild } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
import { PlatformUtil } from '../core/utils';
/** @type {?} */
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
export class IgxNavigationDrawerComponent {
    /**
     * @param {?} elementRef
     * @param {?} _state
     * @param {?} renderer
     * @param {?} _touchManager
     * @param {?} platformUtil
     */
    constructor(elementRef, _state, renderer, _touchManager, platformUtil) {
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        this.cssClass = 'igx-nav-drawer';
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = `igx-nav-drawer-${NEXT_ID++}`;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = (evt) => {
            if (!this.platformUtil.isBrowser) {
                return;
            }
            /** @type {?} */
            let windowWidth;
            if (this.pinThreshold) {
                windowWidth = this.getWindowWidth();
                if (evt && this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                this._widthCache.windowWidth = windowWidth;
                if (!this.pin && windowWidth >= this.pinThreshold) {
                    this.pin = true;
                    this.pinChange.emit(true);
                }
                else if (this.pin && windowWidth < this.pinThreshold) {
                    this.pin = false;
                    this.pinChange.emit(false);
                }
            }
        };
        this.swipe = (evt) => {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            /** @type {?} */
            let deltaX;
            /** @type {?} */
            let startPosition;
            if (this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < this.maxEdgeZone)) {
                this.toggle();
            }
        };
        this.panstart = (evt) => {
            if (!this.enableGestures || this.pin || evt.pointerType !== 'touch') {
                return;
            }
            /** @type {?} */
            const startPosition = this.position === 'right' ? this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (this.isOpen || (startPosition < this.maxEdgeZone)) {
                this._panning = true;
                this._panStartWidth = this.getExpectedWidth(!this.isOpen);
                this._panLimit = this.getExpectedWidth(this.isOpen);
                this.renderer.setElementClass(this.overlay, 'panning', true);
                this.renderer.setElementClass(this.drawer, 'panning', true);
            }
        };
        this.pan = (evt) => {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!this._panning) {
                return;
            }
            /** @type {?} */
            const right = this.position === 'right';
            // when on the right use inverse of deltaX
            /** @type {?} */
            const deltaX = right ? -evt.deltaX : evt.deltaX;
            /** @type {?} */
            let visibleWidth;
            /** @type {?} */
            let newX;
            /** @type {?} */
            let percent;
            visibleWidth = this._panStartWidth + deltaX;
            if (this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panLimit) / (this._panStartWidth - this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panStartWidth;
                    newX = evt.deltaX;
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= this._panLimit) {
                    return;
                }
                if (this.hasAnimateWidth) {
                    percent = (visibleWidth - this._panStartWidth) / (this._panLimit - this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / this._panLimit;
                    newX = (this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = (evt) => {
            if (this._panning) {
                /** @type {?} */
                const deltaX = this.position === 'right' ? -evt.deltaX : evt.deltaX;
                /** @type {?} */
                const visibleWidth = this._panStartWidth + deltaX;
                this.resetPan();
                // check if pan brought the drawer to 50%
                if (this.isOpen && visibleWidth <= this._panStartWidth / 2) {
                    this.close();
                }
                else if (!this.isOpen && visibleWidth >= this._panLimit / 2) {
                    this.open();
                }
                this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleOpenedEvent, false);
            this.opened.emit();
        };
        this.toggleClosedEvent = (evt) => {
            this.elementRef.nativeElement.removeEventListener('transitionend', this.toggleClosedEvent, false);
            this.closed.emit();
        };
    }
    /**
     * State of the drawer.
     *
     * ```typescript
     * // get
     * let navDrawerIsOpen = this.navdrawer.isOpen;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
     * ```
     *
     * Two-way data binding.
     * ```html
     * <!--set-->
     * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
     * ```
     * @return {?}
     */
    get isOpen() {
        return this._isOpen;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set isOpen(value) {
        this._isOpen = value;
        this.isOpenChange.emit(this._isOpen);
    }
    /**
     * Returns nativeElement of the component.
     *
     * @hidden
     * @return {?}
     */
    get element() {
        return this.elementRef.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.miniTemplate && !this.isOpen) {
            return this.miniTemplate.template;
        }
        else if (this.contentTemplate) {
            return this.contentTemplate.template;
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    get miniTemplate() {
        return this._miniTemplate;
    }
    /**
     * @hidden
     * @param {?} v
     * @return {?}
     */
    set miniTemplate(v) {
        if (!this.isOpen) {
            this.setDrawerWidth(v ? this.miniWidth : '');
        }
        this._miniTemplate = v;
    }
    /**
     * @hidden
     * @return {?}
     */
    get flexWidth() {
        if (!this.pin) {
            return '0px';
        }
        if (this.isOpen) {
            return this.width;
        }
        if (this.miniTemplate && this.miniWidth) {
            return this.miniWidth;
        }
        return '0px';
    }
    /**
     * @hidden
     * @return {?}
     */
    get isPinnedRight() {
        return this.pin && this.position === 'right' ? '1' : '0';
    }
    /**
     * @hidden
     * @return {?}
     */
    get drawer() {
        return this._drawer.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get overlay() {
        return this._overlay.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    get styleDummy() {
        return this._styleDummy.nativeElement;
    }
    /**
     * Property to decide whether to change width or translate the drawer from pan gesture.
     *
     * @hidden
     * @return {?}
     */
    get hasAnimateWidth() {
        return this.pin || !!this.miniTemplate;
    }
    /**
     * Used for touch gestures (swipe and pan).
     * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
     *
     * @hidden
     * @return {?}
     */
    get maxEdgeZone() {
        return this._maxEdgeZone;
    }
    /**
     * Gets the Drawer width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     *
     * @hidden
     * @return {?}
     */
    get expectedWidth() {
        return this.getExpectedWidth(false);
    }
    /**
     * Get the Drawer mini width for specific state.
     * Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @return {?}
     */
    get expectedMiniWidth() {
        return this.getExpectedWidth(true);
    }
    /**
     * @hidden
     * @return {?}
     */
    get touchManager() {
        return this._touchManager;
    }
    /**
     * Exposes optional navigation service
     *
     * @hidden
     * @return {?}
     */
    get state() {
        return this._state;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    }
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    }
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    toggle() {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    }
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    open() {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    }
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    close() {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    }
    /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    set_maxEdgeZone(value) {
        this._maxEdgeZone = value;
    }
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    getExpectedWidth(mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                }
                return this._widthCache.width;
            }
        }
    }
    /**
     * @private
     * @return {?}
     */
    getWindowWidth() {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    }
    /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    setDrawerWidth(width) {
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(() => {
                if (this.drawer) {
                    this.renderer.setElementStyle(this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setElementStyle(this.drawer, 'width', width);
        }
    }
    /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    getDrawerWidth() {
        return this.drawer.offsetWidth;
    }
    /**
     * @private
     * @return {?}
     */
    ensureEvents() {
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(() => interval(150)))
                .subscribe((value) => {
                this.checkPinThreshold(value);
            });
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateEdgeZone() {
        /** @type {?} */
        let maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    }
    /**
     * @private
     * @return {?}
     */
    resetPan() {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    }
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    setXSize(x, opacity) {
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(() => {
            if (this.hasAnimateWidth) {
                this.renderer.setElementStyle(this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                /** @type {?} */
                const transform = x ? 'translate3d(' + x + 'px,0,0)' : '';
                this.renderer.setElementStyle(this.drawer, 'transform', transform);
                this.renderer.setElementStyle(this.drawer, '-webkit-transform', transform);
            }
            if (opacity !== undefined) {
                this.renderer.setElementStyle(this.overlay, 'opacity', opacity);
            }
        });
    }
}
IgxNavigationDrawerComponent.decorators = [
    { type: Component, args: [{
                providers: [HammerGesturesManager],
                selector: 'igx-nav-drawer',
                template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                styles: [`
        :host {
            display: block;
            height: 100%;
        }
    `]
            }] }
];
/** @nocollapse */
IgxNavigationDrawerComponent.ctorParameters = () => [
    { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
    { type: IgxNavigationService, decorators: [{ type: Optional }] },
    { type: Renderer },
    { type: HammerGesturesManager },
    { type: PlatformUtil }
];
IgxNavigationDrawerComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    position: [{ type: Input }],
    enableGestures: [{ type: Input }],
    isOpen: [{ type: Input }],
    isOpenChange: [{ type: Output }],
    pin: [{ type: Input }],
    pinThreshold: [{ type: Input }],
    width: [{ type: Input }],
    miniWidth: [{ type: Input }],
    pinChange: [{ type: Output }],
    opening: [{ type: Output }],
    opened: [{ type: Output }],
    closing: [{ type: Output }],
    closed: [{ type: Output }],
    miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective, static: false },] }],
    contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective, static: false },] }],
    flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
    isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
    _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
    _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
    _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._isOpen;
    /** @type {?} */
    IgxNavigationDrawerComponent.prototype.cssClass;
    /**
     * ID of the component
     *
     * ```typescript
     * // get
     * let myNavDrawerId = this.navdrawer.id;
     * ```
     *
     * ```html
     * <!--set-->
     *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.id;
    /**
     * Position of the Navigation Drawer. Can be "left"(default) or "right".
     *
     * ```typescript
     * // get
     * let myNavDrawerPosition = this.navdrawer.position;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.position;
    /**
     * Enables the use of touch gestures to manipulate the drawer:
     * - swipe/pan from edge to open, swipe-toggle and pan-drag.
     *
     * ```typescript
     * // get
     * let gesturesEnabled = this.navdrawer.enableGestures;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.enableGestures;
    /**
     * @hidden
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.isOpenChange;
    /**
     * When pinned the drawer is relatively positioned instead of sitting above content.
     * May require additional layout styling.
     *
     * ```typescript
     * // get
     * let navDrawerIsPinned = this.navdrawer.pin;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pin;
    /**
     * Minimum device width required for automatic pin to be toggled.
     * Default is 1024, can be set to a falsy value to disable this behavior.
     *
     * ```typescript
     * // get
     * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinThreshold;
    /**
     * Width of the drawer in its open state. Defaults to "280px".
     *
     * ```typescript
     * // get
     * let navDrawerWidth = this.navdrawer.width;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.width;
    /**
     * Width of the drawer in its mini state. Defaults to 68px.
     *
     * ```typescript
     * // get
     * let navDrawerMiniWidth = this.navdrawer.miniWidth;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.miniWidth;
    /**
     * Pinned state change output for two-way binding.
     *
     * ```html
     * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinChange;
    /**
     * Event fired as the Navigation Drawer is about to open.
     *
     * ```html
     *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opening;
    /**
     * Event fired when the Navigation Drawer has opened.
     *
     * ```html
     * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opened;
    /**
     * Event fired as the Navigation Drawer is about to close.
     *
     * ```html
     * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closing;
    /**
     * Event fired when the Navigation Drawer has closed.
     *
     * ```html
     * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._miniTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxNavigationDrawerComponent.prototype.contentTemplate;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._gesturesAttached;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._widthCache;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.css;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._drawer;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._styleDummy;
    /**
     * Pan animation properties
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panning;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panStartWidth;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panLimit;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._maxEdgeZone;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.checkPinThreshold;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.swipe;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.panstart;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.pan;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.panEnd;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.toggleOpenedEvent;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.toggleClosedEvent;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._state;
    /**
     * @type {?}
     * @protected
     */
    IgxNavigationDrawerComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._touchManager;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.platformUtil;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9uYXZpZ2F0aW9uLWRyYXdlci9uYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLE1BQU0sRUFDTixRQUFRLEVBRVIsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sb0JBQW9CLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ2xILE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7O0lBRXpDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFnQ2YsTUFBTSxPQUFPLDRCQUE0Qjs7Ozs7Ozs7SUFzV3JDLFlBQ2dDLFVBQXNCLEVBQzlCLE1BQTRCLEVBRXRDLFFBQWtCLEVBQ3BCLGFBQW9DLEVBQ3BDLFlBQTBCO1FBTE4sZUFBVSxHQUFWLFVBQVUsQ0FBWTtRQUM5QixXQUFNLEdBQU4sTUFBTSxDQUFzQjtRQUV0QyxhQUFRLEdBQVIsUUFBUSxDQUFVO1FBQ3BCLGtCQUFhLEdBQWIsYUFBYSxDQUF1QjtRQUNwQyxpQkFBWSxHQUFaLFlBQVksQ0FBYztRQXRXOUIsWUFBTyxHQUFHLEtBQUss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eURBR0M7Ozs7O0lBdmFHLGtEQUFrRDs7Ozs7SUFDbEQsOENBQWdEOzs7OztJQUVoRCxnREFBNEI7Ozs7O0lBQzVCLHFEQUE0Qzs7Ozs7SUFDNUMsb0RBQWtDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIENvbXBvbmVudCxcbiAgICBDb250ZW50Q2hpbGQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5qZWN0LFxuICAgIElucHV0LFxuICAgIE9uQ2hhbmdlcyxcbiAgICBPbkRlc3Ryb3ksXG4gICAgT25Jbml0LFxuICAgIE9wdGlvbmFsLFxuICAgIE91dHB1dCxcbiAgICBSZW5kZXJlcixcbiAgICBTaW1wbGVDaGFuZ2UsXG4gICAgVmlld0NoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBpbnRlcnZhbCwgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZSB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElneE5hdmlnYXRpb25TZXJ2aWNlLCBJVG9nZ2xlVmlldyB9IGZyb20gJy4uL2NvcmUvbmF2aWdhdGlvbic7XG5pbXBvcnQgeyBIYW1tZXJHZXN0dXJlc01hbmFnZXIgfSBmcm9tICcuLi9jb3JlL3RvdWNoJztcbmltcG9ydCB7IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmUgfSBmcm9tICcuL25hdmlnYXRpb24tZHJhd2VyLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbmxldCBORVhUX0lEID0gMDtcbi8qKlxuICogKipJZ25pdGUgVUkgZm9yIEFuZ3VsYXIgTmF2aWdhdGlvbiBEcmF3ZXIqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvbmF2ZHJhd2VyLmh0bWwpXG4gKlxuICogVGhlIElnbml0ZSBVSSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhIGNvbGxhcHNpYmxlIHNpZGUgbmF2aWdhdGlvbiBjb250YWluZXIgY29tbW9ubHkgdXNlZCBpbiBjb21iaW5hdGlvbiB3aXRoIHRoZSBOYXZiYXIuXG4gKlxuICogRXhhbXBsZTpcbiAqIGBgYGh0bWxcbiAqIDxpZ3gtbmF2LWRyYXdlciBpZD1cIm5hdmlnYXRpb25cIiBbaXNPcGVuXT1cInRydWVcIj5cbiAqICAgPG5nLXRlbXBsYXRlIGlneERyYXdlcj5cbiAqICAgICA8bmF2PlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBbaXNIZWFkZXJdPVwidHJ1ZVwiPkVtYWlsPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+SW5ib3g8L3NwYW4+XG4gKiAgICAgICA8c3BhbiBpZ3hEcmF3ZXJJdGVtIGlneFJpcHBsZT5EZWxldGVkPC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+U2VudDwvc3Bhbj5cbiAqICAgICA8L25hdj5cbiAqICAgPC9uZy10ZW1wbGF0ZT5cbiAqIDwvaWd4LW5hdi1kcmF3ZXI+XG4gKiBgYGBcbiAqL1xuQENvbXBvbmVudCh7XG4gICAgcHJvdmlkZXJzOiBbSGFtbWVyR2VzdHVyZXNNYW5hZ2VyXSxcbiAgICBzZWxlY3RvcjogJ2lneC1uYXYtZHJhd2VyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ25hdmlnYXRpb24tZHJhd2VyLmNvbXBvbmVudC5odG1sJyxcbiAgICBzdHlsZXM6IFtgXG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB9XG4gICAgYF1cbn0pXG5leHBvcnQgY2xhc3MgSWd4TmF2aWdhdGlvbkRyYXdlckNvbXBvbmVudCBpbXBsZW1lbnRzXG4gICAgSVRvZ2dsZVZpZXcsXG4gICAgT25Jbml0LFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgT25EZXN0cm95LFxuICAgIE9uQ2hhbmdlcyB7XG4gICAgcHJpdmF0ZSBfaXNPcGVuID0gZmFsc2U7XG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcycpIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtbmF2LWRyYXdlcic7XG5cbiAgICAvKipcbiAgICAgKiBJRCBvZiB0aGUgY29tcG9uZW50XG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15TmF2RHJhd2VySWQgPSB0aGlzLm5hdmRyYXdlci5pZDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogIDxpZ3gtbmF2LWRyYXdlciBpZD0nbmF2ZHJhd2VyJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5pZCcpXG4gICAgQElucHV0KCkgcHVibGljIGlkID0gYGlneC1uYXYtZHJhd2VyLSR7TkVYVF9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBQb3NpdGlvbiBvZiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIENhbiBiZSBcImxlZnRcIihkZWZhdWx0KSBvciBcInJpZ2h0XCIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG15TmF2RHJhd2VyUG9zaXRpb24gPSB0aGlzLm5hdmRyYXdlci5wb3NpdGlvbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtwb3NpdGlvbl09XCInbGVmdCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwb3NpdGlvbiA9ICdsZWZ0JztcblxuICAgIC8qKlxuICAgICAqIEVuYWJsZXMgdGhlIHVzZSBvZiB0b3VjaCBnZXN0dXJlcyB0byBtYW5pcHVsYXRlIHRoZSBkcmF3ZXI6XG4gICAgICogLSBzd2lwZS9wYW4gZnJvbSBlZGdlIHRvIG9wZW4sIHN3aXBlLXRvZ2dsZSBhbmQgcGFuLWRyYWcuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IGdlc3R1cmVzRW5hYmxlZCA9IHRoaXMubmF2ZHJhd2VyLmVuYWJsZUdlc3R1cmVzO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW2VuYWJsZUdlc3R1cmVzXT0ndHJ1ZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgZW5hYmxlR2VzdHVyZXMgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU3RhdGUgb2YgdGhlIGRyYXdlci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNPcGVuID0gdGhpcy5uYXZkcmF3ZXIuaXNPcGVuO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW2lzT3Blbl09J2ZhbHNlJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgWyhpc09wZW4pXT0nbW9kZWwuaXNPcGVuJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpc09wZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc09wZW47XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaXNPcGVuKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2lzT3BlbiA9IHZhbHVlO1xuICAgICAgICB0aGlzLmlzT3BlbkNoYW5nZS5lbWl0KHRoaXMuX2lzT3Blbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBpc09wZW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHBpbm5lZCB0aGUgZHJhd2VyIGlzIHJlbGF0aXZlbHkgcG9zaXRpb25lZCBpbnN0ZWFkIG9mIHNpdHRpbmcgYWJvdmUgY29udGVudC5cbiAgICAgKiBNYXkgcmVxdWlyZSBhZGRpdGlvbmFsIGxheW91dCBzdHlsaW5nLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJJc1Bpbm5lZCA9IHRoaXMubmF2ZHJhd2VyLnBpbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtwaW5dPSdmYWxzZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGluID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBNaW5pbXVtIGRldmljZSB3aWR0aCByZXF1aXJlZCBmb3IgYXV0b21hdGljIHBpbiB0byBiZSB0b2dnbGVkLlxuICAgICAqIERlZmF1bHQgaXMgMTAyNCwgY2FuIGJlIHNldCB0byBhIGZhbHN5IHZhbHVlIHRvIGRpc2FibGUgdGhpcyBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VyUGluVHJlc2hvbGQgPSB0aGlzLm5hdmRyYXdlci5waW5UaHJlc2hvbGQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluVHJlc2hvbGRdPScxMDI0Jz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyBwaW5UaHJlc2hvbGQgPSAxMDI0O1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBuYXRpdmVFbGVtZW50IG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBvcGVuIHN0YXRlLiBEZWZhdWx0cyB0byBcIjI4MHB4XCIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcldpZHRoID0gdGhpcy5uYXZkcmF3ZXIud2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbd2lkdGhdPVwiJzIyOHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHdpZHRoID0gJzI4MHB4JztcblxuICAgIC8qKlxuICAgICAqIFdpZHRoIG9mIHRoZSBkcmF3ZXIgaW4gaXRzIG1pbmkgc3RhdGUuIERlZmF1bHRzIHRvIDY4cHguXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlck1pbmlXaWR0aCA9IHRoaXMubmF2ZHJhd2VyLm1pbmlXaWR0aDtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFttaW5pV2lkdGhdPVwiJzM0cHgnXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgbWluaVdpZHRoID0gJzY4cHgnO1xuXG4gICAgLyoqXG4gICAgICogUGlubmVkIHN0YXRlIGNoYW5nZSBvdXRwdXQgZm9yIHR3by13YXkgYmluZGluZy5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgWyhwaW4pXT0naXNQaW5uZWQnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBwaW5DaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KHRydWUpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGFzIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhYm91dCB0byBvcGVuLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LW5hdi1kcmF3ZXIgKG9wZW5pbmcpPSdvbk9wZW5pbmcoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIG9wZW5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaGFzIG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKG9wZW5lZCk9J29uT3BlbmVkKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgYXMgdGhlIE5hdmlnYXRpb24gRHJhd2VyIGlzIGFib3V0IHRvIGNsb3NlLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciAoY2xvc2luZyk9J29uQ2xvc2luZygpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgY2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCB3aGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBoYXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciAoY2xvc2VkKT0nb25DbG9zZWQoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1pbmlUZW1wbGF0ZSAmJiAhdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmNvbnRlbnRUZW1wbGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFRlbXBsYXRlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWluaVRlbXBsYXRlOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmU7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWluaVRlbXBsYXRlKCk6IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9taW5pVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgc3RhdGljOiBmYWxzZSB9KVxuICAgIHB1YmxpYyBzZXQgbWluaVRlbXBsYXRlKHY6IElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSkge1xuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHYgPyB0aGlzLm1pbmlXaWR0aCA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9taW5pVGVtcGxhdGUgPSB2O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHJvdGVjdGVkIGNvbnRlbnRUZW1wbGF0ZTogSWd4TmF2RHJhd2VyVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5mbGV4QmFzaXMnKVxuICAgIGdldCBmbGV4V2lkdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5waW4pIHtcbiAgICAgICAgICAgIHJldHVybiAnMHB4JztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbmlUZW1wbGF0ZSAmJiB0aGlzLm1pbmlXaWR0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWluaVdpZHRoO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcwcHgnO1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgQEhvc3RCaW5kaW5nKCdzdHlsZS5vcmRlcicpXG4gICAgZ2V0IGlzUGlubmVkUmlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBpbiAmJiB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gJzEnIDogJzAnO1xuICAgIH1cblxuICAgIHByaXZhdGUgX2dlc3R1cmVzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICBwcml2YXRlIF93aWR0aENhY2hlOiB7IHdpZHRoOiBudW1iZXIsIG1pbmlXaWR0aDogbnVtYmVyLCB3aW5kb3dXaWR0aDogbnVtYmVyIH0gPSB7IHdpZHRoOiBudWxsLCBtaW5pV2lkdGg6IG51bGwsIHdpbmRvd1dpZHRoOiBudWxsIH07XG4gICAgcHJpdmF0ZSBfcmVzaXplT2JzZXJ2ZXI6IFN1YnNjcmlwdGlvbjtcbiAgICBwcml2YXRlIGNzczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nOyB9ID0ge1xuICAgICAgICBkcmF3ZXI6ICdpZ3gtbmF2LWRyYXdlcl9fYXNpZGUnLFxuICAgICAgICBtaW5pOiAnaWd4LW5hdi1kcmF3ZXJfX2FzaWRlLS1taW5pJyxcbiAgICAgICAgb3ZlcmxheTogJ2lneC1uYXYtZHJhd2VyX19vdmVybGF5JyxcbiAgICAgICAgc3R5bGVEdW1teTogJ2lneC1uYXYtZHJhd2VyX19zdHlsZS1kdW1teSdcbiAgICB9O1xuXG4gICAgQFZpZXdDaGlsZCgnYXNpZGUnLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIF9kcmF3ZXI6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnb3ZlcmxheScsIHsgc3RhdGljOiB0cnVlIH0pIHByaXZhdGUgX292ZXJsYXk6IEVsZW1lbnRSZWY7XG4gICAgQFZpZXdDaGlsZCgnZHVtbXknLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIF9zdHlsZUR1bW15OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICAqIEBoaWRkZW5cbiAgICAgICovXG4gICAgZ2V0IGRyYXdlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RyYXdlci5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgb3ZlcmxheSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXkubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHN0eWxlRHVtbXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zdHlsZUR1bW15Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqIFBhbiBhbmltYXRpb24gcHJvcGVydGllcyAqL1xuICAgIHByaXZhdGUgX3Bhbm5pbmcgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9wYW5TdGFydFdpZHRoOiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfcGFuTGltaXQ6IG51bWJlcjtcblxuICAgIC8qKlxuICAgICAqIFByb3BlcnR5IHRvIGRlY2lkZSB3aGV0aGVyIHRvIGNoYW5nZSB3aWR0aCBvciB0cmFuc2xhdGUgdGhlIGRyYXdlciBmcm9tIHBhbiBnZXN0dXJlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFzQW5pbWF0ZVdpZHRoKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gfHwgISF0aGlzLm1pbmlUZW1wbGF0ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9tYXhFZGdlWm9uZSA9IDUwO1xuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIHRvdWNoIGdlc3R1cmVzIChzd2lwZSBhbmQgcGFuKS5cbiAgICAgKiBEZWZhdWx0cyB0byA1MCAoaW4gcHgpIGFuZCBpcyBleHRlbmRlZCB0byBhdCBsZWFzdCAxMTAlIG9mIHRoZSBtaW5pIHRlbXBsYXRlIHdpZHRoIGlmIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1heEVkZ2Vab25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4RWRnZVpvbmU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgRHJhd2VyIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS5cbiAgICAgKiBXaWxsIGF0dGVtcHQgdG8gZXZhbHVhdGUgcmVxdWVzdGVkIHN0YXRlIGFuZCBjYWNoZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXhwZWN0ZWRXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aChmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBEcmF3ZXIgbWluaSB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuXG4gICAgICogV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBleHBlY3RlZE1pbmlXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCB0b3VjaE1hbmFnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90b3VjaE1hbmFnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhwb3NlcyBvcHRpb25hbCBuYXZpZ2F0aW9uIHNlcnZpY2VcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RhdGU7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoRWxlbWVudFJlZikgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBwcml2YXRlIF9zdGF0ZTogSWd4TmF2aWdhdGlvblNlcnZpY2UsXG4gICAgICAgIC8vIHByaXZhdGUgYW5pbWF0ZTogQW5pbWF0aW9uQnVpbGRlciwgVE9ET1xuICAgICAgICBwcm90ZWN0ZWQgcmVuZGVyZXI6IFJlbmRlcmVyLFxuICAgICAgICBwcml2YXRlIF90b3VjaE1hbmFnZXI6IEhhbW1lckdlc3R1cmVzTWFuYWdlcixcbiAgICAgICAgcHJpdmF0ZSBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkluaXQoKSB7XG4gICAgICAgIC8vIERPTSBhbmQgQElucHV0KCktcyBpbml0aWFsaXplZFxuICAgICAgICBpZiAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlLmFkZCh0aGlzLmlkLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgodGhpcy53aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgLy8gd2FpdCBmb3IgdGVtcGxhdGUgYW5kIG5nLWNvbnRlbnQgdG8gYmUgcmVhZHlcbiAgICAgICAgdGhpcy51cGRhdGVFZGdlWm9uZSgpO1xuICAgICAgICB0aGlzLmNoZWNrUGluVGhyZXNob2xkKCk7XG5cbiAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcblxuICAgICAgICAvLyBUT0RPOiBhcHBseSBwbGF0Zm9ybS1zYWZlIFJ1bGVyIGZyb20gaHR0cDovL3BsbmtyLmNvL2VkaXQvODFuV0R5cmVZTXprdW5paGZSZ1g/cD1wcmV2aWV3XG4gICAgICAgIC8vIChodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82NTE1KSwgYmxvY2tlZCBieSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82OTA0XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5yZW1vdmUodGhpcy5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZU9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiB7IFtwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0pIHtcbiAgICAgICAgLy8gc2ltcGxlIHNldHRpbmdzIGNhbiBjb21lIGZyb20gYXR0cmlidXRlIHNldCAocmF0aGVyIHRoYW4gYmluZGluZyksIG1ha2Ugc3VyZSBib29sZWFuIHByb3BzIGFyZSBjb252ZXJ0ZWRcbiAgICAgICAgaWYgKGNoYW5nZXMuZW5hYmxlR2VzdHVyZXMgJiYgY2hhbmdlcy5lbmFibGVHZXN0dXJlcy5jdXJyZW50VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGVHZXN0dXJlcyA9ICEhKHRoaXMuZW5hYmxlR2VzdHVyZXMgJiYgdGhpcy5lbmFibGVHZXN0dXJlcy50b1N0cmluZygpID09PSAndHJ1ZScpO1xuICAgICAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcy5waW4gJiYgY2hhbmdlcy5waW4uY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGluID0gISEodGhpcy5waW4gJiYgdGhpcy5waW4udG9TdHJpbmcoKSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBpbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoYW5nZXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuc3VyZUV2ZW50cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQaW5UaHJlc2hvbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLndpZHRoICYmIHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKGNoYW5nZXMud2lkdGguY3VycmVudFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLm1pbmlXaWR0aCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RHJhd2VyV2lkdGgoY2hhbmdlcy5taW5pV2lkdGguY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRnZVpvbmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZSB0aGUgb3BlbiBzdGF0ZSBvZiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIudG9nZ2xlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBIYXMgbm8gZWZmZWN0IGlmIGFscmVhZHkgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZW5pbmcuZW1pdCgpO1xuICAgICAgICB0aGlzLmlzT3BlbiA9IHRydWU7XG5cbiAgICAgICAgLy8gVE9ETzogU3dpdGNoIHRvIGFuaW1hdGUgQVBJIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgIC8vIHZhciBhbmltYXRpb25Dc3MgPSB0aGlzLmFuaW1hdGUuY3NzKCk7XG4gICAgICAgIC8vICAgICBhbmltYXRpb25Dc3NcbiAgICAgICAgLy8gICAgICAgICAuc2V0U3R5bGVzKHsnd2lkdGgnOic1MHB4J30sIHsnd2lkdGgnOic0MDBweCd9KVxuICAgICAgICAvLyAgICAgICAgIC5zdGFydCh0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudClcbiAgICAgICAgLy8gICAgICAgICAub25Db21wbGV0ZSgoKSA9PiBhbmltYXRpb25Dc3Muc2V0VG9TdHlsZXMoeyd3aWR0aCc6J2F1dG8nfSkuc3RhcnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpKTtcblxuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVPcGVuZWRFdmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMud2lkdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW4oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zaW5nLmVtaXQoKTtcblxuICAgICAgICB0aGlzLmlzT3BlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMubWluaVRlbXBsYXRlID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZUNsb3NlZEV2ZW50LCBmYWxzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzZXRfbWF4RWRnZVpvbmUodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tYXhFZGdlWm9uZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIHdpZHRoIGZvciBzcGVjaWZpYyBzdGF0ZS4gV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQHBhcmFtIFttaW5pXSAtIFJlcXVlc3QgbWluaSB3aWR0aCBpbnN0ZWFkXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGdldEV4cGVjdGVkV2lkdGgobWluaT86IGJvb2xlYW4pOiBudW1iZXIge1xuICAgICAgICBpZiAobWluaSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLm1pbmlUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubWluaVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy5taW5pV2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXRoaXMuaXNPcGVuKSB7IC8vIFRoaXMgV09OJ1Qgd29yayBkdWUgdG8gdHJhbnNpdGlvbiB0aW1pbmdzLi4uXG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jaGlsZHJlblsxXS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAvLyB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aENhY2hlLm1pbmlXaWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBjbGFzcyBmb3Igd2lkdGggY2FsYy4gVE9ETz9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLm1pbmksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLm1pbmlXaWR0aCA9IHRoaXMuc3R5bGVEdW1teS5vZmZzZXRXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5taW5pLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aENhY2hlLm1pbmlXaWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodGhpcy53aWR0aCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl93aWR0aENhY2hlLndpZHRoID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcmNlIGNsYXNzIGZvciB3aWR0aCBjYWxjLiBUT0RPP1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUud2lkdGggPSB0aGlzLnN0eWxlRHVtbXkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl93aWR0aENhY2hlLndpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRXaW5kb3dXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cuaW5uZXJXaWR0aCA+IDApID8gd2luZG93LmlubmVyV2lkdGggOiBzY3JlZW4ud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgZHJhd2VyIHdpZHRoLlxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0RHJhd2VyV2lkdGgod2lkdGg6IHN0cmluZykge1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRyYXdlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IERyYXdlciB3aWR0aC5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldERyYXdlcldpZHRoKCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmRyYXdlci5vZmZzZXRXaWR0aDtcbiAgICB9XG5cbiAgICBwcml2YXRlIGVuc3VyZUV2ZW50cygpIHtcbiAgICAgICAgLy8gc2V0IGxpc3RlbmVycyBmb3Igc3dpcGUvcGFuIG9ubHkgaWYgbmVlZGVkLCBidXQganVzdCBvbmNlXG4gICAgICAgIGlmICh0aGlzLmVuYWJsZUdlc3R1cmVzICYmICF0aGlzLnBpbiAmJiAhdGhpcy5fZ2VzdHVyZXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgLy8gQnVpbHQtaW4gbWFuYWdlciBoYW5kbGVyKEwyMDg4NykgY2F1c2VzIGVuZGxlc3MgbG9vcCBhbmQgbWF4IHN0YWNrIGV4Y2VwdGlvbi5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzY5OTNcbiAgICAgICAgICAgIC8vIFVzZSBvdXJzIGZvciBub3cgKHVudGlsIGJldGEuMTApOlxuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwic3dpcGVcIiwgdGhpcy5zd2lwZSk7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAnc3dpcGUnLCB0aGlzLnN3aXBlKTtcbiAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVzQXR0YWNoZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJwYW5zdGFydFwiLCB0aGlzLnBhbnN0YXJ0KTtcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInBhblwiLCB0aGlzLnBhbik7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFuc3RhcnQnLCB0aGlzLnBhbnN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5tb3ZlJywgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3BhbmVuZCcsIHRoaXMucGFuRW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3Jlc2l6ZU9ic2VydmVyICYmIHRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJykucGlwZShkZWJvdW5jZSgoKSA9PiBpbnRlcnZhbCgxNTApKSlcbiAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGluVGhyZXNob2xkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdXBkYXRlRWRnZVpvbmUoKSB7XG4gICAgICAgIGxldCBtYXhWYWx1ZTtcblxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG1heFZhbHVlID0gTWF0aC5tYXgodGhpcy5fbWF4RWRnZVpvbmUsIHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0cnVlKSAqIDEuMSk7XG4gICAgICAgICAgICB0aGlzLnNldF9tYXhFZGdlWm9uZShtYXhWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGNoZWNrUGluVGhyZXNob2xkID0gKGV2dD86IEV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHdpbmRvd1dpZHRoO1xuICAgICAgICBpZiAodGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gdGhpcy5nZXRXaW5kb3dXaWR0aCgpO1xuICAgICAgICAgICAgaWYgKGV2dCAmJiB0aGlzLl93aWR0aENhY2hlLndpbmRvd1dpZHRoID09PSB3aW5kb3dXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3dpZHRoQ2FjaGUud2luZG93V2lkdGggPSB3aW5kb3dXaWR0aDtcbiAgICAgICAgICAgIGlmICghdGhpcy5waW4gJiYgd2luZG93V2lkdGggPj0gdGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5DaGFuZ2UuZW1pdCh0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5waW4gJiYgd2luZG93V2lkdGggPCB0aGlzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucGluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5DaGFuZ2UuZW1pdChmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHN3aXBlID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgLy8gVE9ETzogQ291bGQgYWxzbyBmb3JjZSBpbnB1dCB0eXBlOiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNzEwODA1MlxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlR2VzdHVyZXMgfHwgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBIYW1tZXJKUyBzd2lwZSBpcyBob3Jpem9udGFsLW9ubHkgYnkgZGVmYXVsdCwgZG9uJ3QgY2hlY2sgZGVsdGFZXG4gICAgICAgIGxldCBkZWx0YVg7XG4gICAgICAgIGxldCBzdGFydFBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICAgICAgLy8gd2hlbiBvbiB0aGUgcmlnaHQgdXNlIGludmVyc2Ugb2YgZGVsdGFYXG4gICAgICAgICAgICBkZWx0YVggPSAtZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIHN0YXJ0UG9zaXRpb24gPSB0aGlzLmdldFdpbmRvd1dpZHRoKCkgLSAoZXZ0LmNlbnRlci54ICsgZXZ0LmRpc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2dC5kZWx0YVg7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gZXZ0LmNlbnRlci54IC0gZXZ0LmRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgYWNjZXB0IGNsb3Npbmcgc3dpcGUgKGlnbm9yaW5nIG1pbkVkZ2Vab25lKSB3aGVuIHRoZSBkcmF3ZXIgaXMgZXhwYW5kZWQ6XG4gICAgICAgIGlmICgodGhpcy5pc09wZW4gJiYgZGVsdGFYIDwgMCkgfHxcbiAgICAgICAgICAgIC8vIHBvc2l0aXZlIGRlbHRhWCBmcm9tIHRoZSBlZGdlOlxuICAgICAgICAgICAgKGRlbHRhWCA+IDAgJiYgc3RhcnRQb3NpdGlvbiA8IHRoaXMubWF4RWRnZVpvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYW5zdGFydCA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7IC8vIFRPRE86IHRlc3QgY29kZVxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlR2VzdHVyZXMgfHwgdGhpcy5waW4gfHwgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnRQb3NpdGlvbiA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcgPyB0aGlzLmdldFdpbmRvd1dpZHRoKCkgLSAoZXZ0LmNlbnRlci54ICsgZXZ0LmRpc3RhbmNlKVxuICAgICAgICAgICAgOiBldnQuY2VudGVyLnggLSBldnQuZGlzdGFuY2U7XG5cbiAgICAgICAgLy8gY2FjaGUgd2lkdGggZHVyaW5nIGFuaW1hdGlvbiwgZmxhZyB0byBhbGxvdyBmdXJ0aGVyIGhhbmRsaW5nXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiB8fCAoc3RhcnRQb3NpdGlvbiA8IHRoaXMubWF4RWRnZVpvbmUpKSB7XG4gICAgICAgICAgICB0aGlzLl9wYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX3BhblN0YXJ0V2lkdGggPSB0aGlzLmdldEV4cGVjdGVkV2lkdGgoIXRoaXMuaXNPcGVuKTtcbiAgICAgICAgICAgIHRoaXMuX3BhbkxpbWl0ID0gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKHRoaXMuaXNPcGVuKTtcblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5vdmVybGF5LCAncGFubmluZycsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5kcmF3ZXIsICdwYW5uaW5nJywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBhbiA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IGlucHV0LmRlbHRhWCA9IHByZXZEZWx0YS54ICsgKGNlbnRlci54IC0gb2Zmc2V0LngpO1xuICAgICAgICAvLyBnZXQgYWN0dWFsIGRlbHRhIChub3QgdG90YWwgc2Vzc2lvbiBvbmUpIGZyb20gZXZlbnQ/XG4gICAgICAgIC8vIHBhbiBXSUxMIGFsc28gZmlyZSBhZnRlciBhIGZ1bGwgc3dpcGUsIG9ubHkgcmVzaXplIG9uIGZsYWdcbiAgICAgICAgaWYgKCF0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHQ6IGJvb2xlYW4gPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnO1xuICAgICAgICAvLyB3aGVuIG9uIHRoZSByaWdodCB1c2UgaW52ZXJzZSBvZiBkZWx0YVhcbiAgICAgICAgY29uc3QgZGVsdGFYID0gcmlnaHQgPyAtZXZ0LmRlbHRhWCA6IGV2dC5kZWx0YVg7XG4gICAgICAgIGxldCB2aXNpYmxlV2lkdGg7XG4gICAgICAgIGxldCBuZXdYO1xuICAgICAgICBsZXQgcGVyY2VudDtcblxuICAgICAgICB2aXNpYmxlV2lkdGggPSB0aGlzLl9wYW5TdGFydFdpZHRoICsgZGVsdGFYO1xuXG4gICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiBkZWx0YVggPCAwKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHZpc2libGVXaWR0aCBoaXRzIGxpbWl0IC0gc3RvcCBhbmltYXRpbmdcbiAgICAgICAgICAgIGlmICh2aXNpYmxlV2lkdGggPD0gdGhpcy5fcGFuTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0FuaW1hdGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAodmlzaWJsZVdpZHRoIC0gdGhpcy5fcGFuTGltaXQpIC8gKHRoaXMuX3BhblN0YXJ0V2lkdGggLSB0aGlzLl9wYW5MaW1pdCk7XG4gICAgICAgICAgICAgICAgbmV3WCA9IHZpc2libGVXaWR0aDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9IHZpc2libGVXaWR0aCAvIHRoaXMuX3BhblN0YXJ0V2lkdGg7XG4gICAgICAgICAgICAgICAgbmV3WCA9IGV2dC5kZWx0YVg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFhTaXplKG5ld1gsIHBlcmNlbnQudG9QcmVjaXNpb24oMikpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuaXNPcGVuICYmIGRlbHRhWCA+IDApIHtcbiAgICAgICAgICAgIC8vIHdoZW4gdmlzaWJsZVdpZHRoIGhpdHMgbGltaXQgLSBzdG9wIGFuaW1hdGluZ1xuICAgICAgICAgICAgaWYgKHZpc2libGVXaWR0aCA+PSB0aGlzLl9wYW5MaW1pdCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGVyY2VudCA9ICh2aXNpYmxlV2lkdGggLSB0aGlzLl9wYW5TdGFydFdpZHRoKSAvICh0aGlzLl9wYW5MaW1pdCAtIHRoaXMuX3BhblN0YXJ0V2lkdGgpO1xuICAgICAgICAgICAgICAgIG5ld1ggPSB2aXNpYmxlV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSB2aXNpYmxlV2lkdGggLyB0aGlzLl9wYW5MaW1pdDtcbiAgICAgICAgICAgICAgICBuZXdYID0gKHRoaXMuX3BhbkxpbWl0IC0gdmlzaWJsZVdpZHRoKSAqIChyaWdodCA/IDEgOiAtMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFhTaXplKG5ld1gsIHBlcmNlbnQudG9QcmVjaXNpb24oMikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYW5FbmQgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/IC1ldnQuZGVsdGFYIDogZXZ0LmRlbHRhWDtcbiAgICAgICAgICAgIGNvbnN0IHZpc2libGVXaWR0aDogbnVtYmVyID0gdGhpcy5fcGFuU3RhcnRXaWR0aCArIGRlbHRhWDtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQYW4oKTtcblxuICAgICAgICAgICAgLy8gY2hlY2sgaWYgcGFuIGJyb3VnaHQgdGhlIGRyYXdlciB0byA1MCVcbiAgICAgICAgICAgIGlmICh0aGlzLmlzT3BlbiAmJiB2aXNpYmxlV2lkdGggPD0gdGhpcy5fcGFuU3RhcnRXaWR0aCAvIDIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzT3BlbiAmJiB2aXNpYmxlV2lkdGggPj0gdGhpcy5fcGFuTGltaXQgLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9wYW5TdGFydFdpZHRoID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVzZXRQYW4oKSB7XG4gICAgICAgIHRoaXMuX3Bhbm5pbmcgPSBmYWxzZTtcbiAgICAgICAgLyogc3R5bGVzIGZhaWwgdG8gYXBwbHkgd2hlbiBzZXQgb24gcGFyZW50IGR1ZSB0byBleHRyYSBhdHRyaWJ1dGVzLCBwcm9iIG5nIGJ1ZyAqL1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLm92ZXJsYXksICdwYW5uaW5nJywgZmFsc2UpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLmRyYXdlciwgJ3Bhbm5pbmcnLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2V0WFNpemUoMCwgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGFic29sdXRlIHBvc2l0aW9uIG9yIHdpZHRoIGluIGNhc2UgdGhlIGRyYXdlciBkb2Vzbid0IGNoYW5nZSBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0geCB0aGUgbnVtYmVyIHBpeGVscyB0byB0cmFuc2xhdGUgb24gdGhlIFggYXhpcyBvciB0aGUgd2lkdGggdG8gc2V0LiAwIHdpZHRoIHdpbGwgY2xlYXIgdGhlIHN0eWxlIGluc3RlYWQuXG4gICAgICogQHBhcmFtIG9wYWNpdHkgb3B0aW9uYWwgdmFsdWUgdG8gYXBwbHkgdG8gdGhlIG92ZXJsYXlcbiAgICAgKi9cbiAgICBwcml2YXRlIHNldFhTaXplKHg6IG51bWJlciwgb3BhY2l0eT86IHN0cmluZykge1xuICAgICAgICAvLyBBbmd1bGFyIHBvbHlmaWxscyBwYXRjaGVzIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIGJ1dCBzd2l0Y2ggdG8gRG9tQWRhcHRlciBBUEkgKFRPRE8pXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQW5pbWF0ZVdpZHRoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHggPyBNYXRoLmFicyh4KSArICdweCcgOiAnJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHggPyAndHJhbnNsYXRlM2QoJyArIHggKyAncHgsMCwwKScgOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRTdHlsZSh0aGlzLmRyYXdlciwgJ3RyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICctd2Via2l0LXRyYW5zZm9ybScsIHRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5vdmVybGF5LCAnb3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZU9wZW5lZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlT3BlbmVkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5vcGVuZWQuZW1pdCgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgdG9nZ2xlQ2xvc2VkRXZlbnQgPSAoZXZ0PykgPT4ge1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVDbG9zZWRFdmVudCwgZmFsc2UpO1xuICAgICAgICB0aGlzLmNsb3NlZC5lbWl0KCk7XG4gICAgfVxufVxuIl19